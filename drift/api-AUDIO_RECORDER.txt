note
	description: "[
				AUDIO_RECORDER - High-Level Audio Recording
		
				Simple, high-level audio recording for Eiffel applications.
				Provides event-driven callbacks for real-time audio processing.
		
				Usage:
					recorder: AUDIO_RECORDER
		
					-- Simple recording to file
					create recorder.make
					recorder.record_to_file ("output.wav", 5.0)  -- 5 seconds
		
					-- Event-driven recording with callback
					recorder.set_on_data_available (agent process_audio)
					recorder.start
					-- ... do other work ...
					recorder.stop
					recorder.buffer.save_to_wav ("output.wav")
		
					-- Real-time audio processing
					recorder.set_on_data_available (agent (buf: AUDIO_BUFFER)
						do
							print ("Peak: " + buf.sample_at (0, 0).abs.out + "%%N")
						end)
	]"
	author: "Larry Rix"
	date: "$Date$"
	revision: "$Revision$"

class interface
	AUDIO_RECORDER

create 
	make
			-- Create recorder using default input device.
		ensure
			defaults_set: sample_rate = 44100 and channels = 2 and bits_per_sample = 16

	make_with_device (a_device: AUDIO_DEVICE)
			-- Create recorder for specific device.
		require
			device_valid: a_device /= Void and then a_device.is_valid
			device_is_input: a_device.is_input
		ensure
			device_set: device = a_device

feature -- Access

	bits_per_sample: INTEGER_32
			-- Bits per sample.

	buffer: detachable AUDIO_BUFFER
			-- Recorded audio data (accumulated).

	channels: INTEGER_32
			-- Number of recording channels.

	device: AUDIO_DEVICE
			-- Input device for recording.

	duration: REAL_64
			-- Total recorded duration in seconds.
		ensure
			non_negative: Result >= 0.0

	generating_type: TYPE [detachable AUDIO_RECORDER]
			-- Type of current object
			-- (type of which it is a direct instance)
			-- (from ANY)
		ensure -- from ANY
			generating_type_not_void: Result /= Void

	generator: STRING_8
			-- Name of current object's generating class
			-- (base class of the type of which it is a direct instance)
			-- (from ANY)
		ensure -- from ANY
			generator_not_void: Result /= Void
			generator_not_empty: not Result.is_empty

	last_error: STRING_8
			-- Error message from last operation.

	sample_rate: INTEGER_32
			-- Recording sample rate in Hz.
	
feature -- Comparison

	frozen deep_equal (a: detachable ANY; b: like arg #1): BOOLEAN
			-- Are `a` and `b` either both void
			-- or attached to isomorphic object structures?
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
			shallow_implies_deep: standard_equal (a, b) implies Result
			both_or_none_void: (a = Void) implies (Result = (b = Void))
			same_type: (Result and (a /= Void)) implies (b /= Void and then a.same_type (b))
			symmetric: Result implies deep_equal (b, a)

	frozen equal (a: detachable ANY; b: like arg #1): BOOLEAN
			-- Are `a` and `b` either both void or attached
			-- to objects considered equal?
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
			definition: Result = (a = Void and b = Void) or else ((a /= Void and b /= Void) and then a.is_equal (b))

	frozen is_deep_equal alias "≡≡≡" (other: AUDIO_RECORDER): BOOLEAN
			-- Are `Current` and `other` attached to isomorphic object structures?
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
		ensure -- from ANY
			shallow_implies_deep: standard_is_equal (other) implies Result
			same_type: Result implies same_type (other)
			symmetric: Result implies other.is_deep_equal (Current)

	is_equal (other: AUDIO_RECORDER): BOOLEAN
			-- Is `other` attached to an object considered
			-- equal to current object?
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
		ensure -- from ANY
			symmetric: Result implies other ~ Current
			consistent: standard_is_equal (other) implies Result

	frozen standard_equal (a: detachable ANY; b: like arg #1): BOOLEAN
			-- Are `a` and `b` either both void or attached to
			-- field-by-field identical objects of the same type?
			-- Always uses default object comparison criterion.
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
			definition: Result = (a = Void and b = Void) or else ((a /= Void and b /= Void) and then a.standard_is_equal (b))

	frozen standard_is_equal alias "≜" (other: AUDIO_RECORDER): BOOLEAN
			-- Is `other` attached to an object of the same type
			-- as current object, and field-by-field identical to it?
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
		ensure -- from ANY
			same_type: Result implies same_type (other)
			symmetric: Result implies other.standard_is_equal (Current)
	
feature -- Status report

	conforms_to (other: ANY): BOOLEAN
			-- Does type of current object conform to type
			-- of `other` (as per Eiffel: The Language, chapter 13)?
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void

	same_type (other: ANY): BOOLEAN
			-- Is type of current object identical to type of `other`?
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
		ensure -- from ANY
			definition: Result = (conforms_to (other) and other.conforms_to (Current))
	
feature -- Duplication

	copy (other: AUDIO_RECORDER)
			-- Update current object using fields of object attached
			-- to `other`, so as to yield equal objects.
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
			type_identity: same_type (other)
		ensure -- from ANY
			is_equal: Current ~ other

	frozen deep_copy (other: AUDIO_RECORDER)
			-- Effect equivalent to that of:
			--		`copy` (`other` . `deep_twin`)
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
		ensure -- from ANY
			deep_equal: deep_equal (Current, other)

	frozen deep_twin: AUDIO_RECORDER
			-- New object structure recursively duplicated from Current.
			-- (from ANY)
		ensure -- from ANY
			deep_twin_not_void: Result /= Void
			deep_equal: deep_equal (Current, Result)

	frozen standard_copy (other: AUDIO_RECORDER)
			-- Copy every field of `other` onto corresponding field
			-- of current object.
			-- (from ANY)
		require -- from ANY
			other_not_void: other /= Void
			type_identity: same_type (other)
		ensure -- from ANY
			is_standard_equal: standard_is_equal (other)

	frozen standard_twin: AUDIO_RECORDER
			-- New object field-by-field identical to `other`.
			-- Always uses default copying semantics.
			-- (from ANY)
		ensure -- from ANY
			standard_twin_not_void: Result /= Void
			equal: standard_equal (Result, Current)

	frozen twin: AUDIO_RECORDER
			-- New object equal to `Current`
			-- `twin` calls `copy`; to change copying/twinning semantics, redefine `copy`.
			-- (from ANY)
		ensure -- from ANY
			twin_not_void: Result /= Void
			is_equal: Result ~ Current
	
feature -- Basic operations

	frozen default: detachable AUDIO_RECORDER
			-- Default value of object's type
			-- (from ANY)

	frozen default_pointer: POINTER
			-- Default value of type `POINTER`
			-- (Avoid the need to write `p`.`default` for
			-- some `p` of type `POINTER`.)
			-- (from ANY)
		ensure -- from ANY
			instance_free: class

	default_rescue
			-- Process exception for routines with no Rescue clause.
			-- (Default: do nothing.)
			-- (from ANY)

	frozen do_nothing
			-- Execute a null action.
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
	
feature -- Callbacks

	on_data_available_action: detachable PROCEDURE [AUDIO_BUFFER]
			-- Called when new audio data is available.
			-- The buffer contains the latest chunk of recorded audio.

	set_on_data_available (a_action: PROCEDURE [AUDIO_BUFFER])
			-- Set callback for real-time audio data.
		require
			action_valid: a_action /= Void
		ensure
			action_set: on_data_available_action = a_action
	
feature -- Configuration

	set_format (a_sample_rate, a_channels, a_bits: INTEGER_32)
			-- Set recording format.
		require
			not_recording: not is_recording
			sample_rate_valid: a_sample_rate > 0
			channels_valid: a_channels > 0 and a_channels <= 8
			bits_valid: a_bits = 8 or a_bits = 16 or a_bits = 24 or a_bits = 32
		ensure
			sample_rate_set: sample_rate = a_sample_rate
			channels_set: channels = a_channels
			bits_set: bits_per_sample = a_bits
	
feature -- Output

	Io: STD_FILES
			-- Handle to standard file setup
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
			io_not_void: Result /= Void

	out: STRING_8
			-- New string containing terse printable representation
			-- of current object
			-- (from ANY)
		ensure -- from ANY
			out_not_void: Result /= Void

	print (o: detachable ANY)
			-- Write terse external representation of `o`
			-- on standard output.
			-- (from ANY)
		ensure -- from ANY
			instance_free: class

	frozen tagged_out: STRING_8
			-- New string containing terse printable representation
			-- of current object
			-- (from ANY)
		ensure -- from ANY
			tagged_out_not_void: Result /= Void
	
feature -- Platform

	Operating_environment: OPERATING_ENVIRONMENT
			-- Objects available from the operating system
			-- (from ANY)
		ensure -- from ANY
			instance_free: class
			operating_environment_not_void: Result /= Void
	
feature -- Processing

	pump
			-- Process recording - call regularly during recording.
			-- Reads audio data from device and accumulates in buffer.
	
feature -- Recording Operations

	record_to_file (a_path: READABLE_STRING_GENERAL; a_duration: REAL_64)
			-- Record for specified duration and save to WAV file.
		require
			path_not_empty: not a_path.is_empty
			duration_positive: a_duration > 0.0
			not_recording: not is_recording

	start
			-- Start recording.
		require
			not_recording: not is_recording
		ensure
			recording_or_error: is_recording or has_error

	stop
			-- Stop recording.
		ensure
			stopped: not is_recording
	
feature -- Status

	has_error: BOOLEAN
			-- Did last operation fail?

	is_recording: BOOLEAN
			-- Is recording in progress?
	
invariant
	device_attached: device /= Void
	last_error_attached: last_error /= Void
	sample_rate_positive: sample_rate > 0
	channels_positive: channels > 0
	bits_valid: bits_per_sample = 8 or bits_per_sample = 16 or bits_per_sample = 24 or bits_per_sample = 32

		-- from ANY
	reflexive_equality: standard_is_equal (Current)
	reflexive_conformance: conforms_to (Current)

end -- class AUDIO_RECORDER

